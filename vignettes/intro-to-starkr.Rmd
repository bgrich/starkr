---
title: "Introduction to starkr"
author: "Brian Richards"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{Introduction to starkr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The starkr package is designed to calculate the Stark matrix and Stark maps 
for Rubidium-85. The code relies heavily on techniques and algorithms used by 
[@Zimmerman1979] in their paper analyzing the Stark structure of alkali-metal 
atoms. The code described below is broken up in to several sections:

* The underlying structure of the Stark matrix elements.
* Creating the Stark matrix elements and Stark matrix.
* Diagonalizing the Stark matrix to create a Stark map.
* Data tidying to create an easier to view and manipulate Stark map.
* Analysis of Stark states at particular field values.

## Components of the Stark matrix element
All of the functions that calcuate the underlying pieces of the Stark matrix 
element may be used independently of the Stark matrix element calculation.

### Quantum Defect
`quantum_defect()` calculates the quantum defect of an arbitrary (n, l, j) 
state of Rubidium-85. The quantum defect is calculated using a modified version 
of equation (16.19) from [_insert Gallagher Rydberg Atoms reference_] pg. 351. 

$$\delta_{n, l, j} = \delta_{0} + \frac{\delta_{2}}{(n - \delta_{0})^{2}}$$

The parameters $\delta_{0}$ and $\delta_{2}$ are experimentally measured values 
from the following papers [_insert Refereneces_].

### Clebsch-Gordan Coefficients and Wigner-3j Symbols
`clebsch_gordan()` calculates the Clebsch-Gordan coefficient for an arbitrary 
selection of quantum numbers j~1~, j~2~, m~1~, m~2~, j, and m~j~. The conditions 
that must be met for a Clebsch-Gordan coefficient are that $m_{1} + m_{2} = 
m_{j}$.

There are two functions that calculate the Clebsch-Gordan coefficient within 
starkr. The first is `clebsch_gordan()` which uses an analytic form which can 
be found in Edmonds [_insert reference_] or Lindgren and Morrison 
[_insert Reference_]. The second is `clebsch_gordan2()` which uses an analytic 
form found in Cromwell's _Group Theory of Physics_ [_insert Reference_].

`wigner_3j()` is provided for completeness and is not actually used in the 
calculation of the Stark matrix element. It is calculated using the 
Clebsch-Gordan coefficient. 

[Insert Examples]

### Spherical Matrix Element
`sphere_mat_element()` calculates the spherical matrix element
$<l, m|\cos{\theta}|l', m>$ based on the form given by @Zimmerman1979.

### Radial Matrix Element
`radial_matrix_element()` calculates the radial matrix element 
$<n, l|r|n', l'>$ for arbitrary quantum numbers n, n', l, and l'. The 
calculation is done using a Numerov algorithm as used by @Zimmerman1979 (see 
Appendix A). This calculation uses the square-root scaling done by @Bhatti1981 
where $\xi = \sqrt{r}$ and $\Psi = r^{3/4} R(r)$.

## Calculating and Building the Stark Matrix

Computing the elements of the Stark matrix and building said matrix requires 
a few additional functions to work together. First, we have to compute the 
individual elements of the Stark matrix. Then we have to put all of those 
elements in to the appropriate spot in the matrix.

### Stark Matrix Elements

The elements of the Stark matrix are calculated using `stark_matrix_elem()`. 
`stark_matrix_elem()` is based on equation 10 from @Zimmerman1979. It requires 
the full $(n, l, j, m_{j})$ of quantum numbers for both the initial and final 
states. Equation 10 from @Zimmerman1979 is reproduced below:

$$<W, l, j, m_{j}|Fz|W', l', j', m_{j}'>$$ 
$$= \delta(m_{j}, m_{j}') \delta(l, l'\pm 1) <W, l| r |W', l'>F$$
$$\times \sum_{m_{l} = m_{j} \pm \frac{1}{2}} 
<l, \frac{1}{2}, m_{l}, m_{j} - m_{l}|j, m_{j}>
<l', \frac{1}{2}, m_{l}, m_{j} - m_{l}|j, m_{j}>
<l, m_{l}|\cos{\theta}|l', m_{l}>$$

where W and W' are the energies of the initial and final states respectively 
and F is the applied electric field. The energy is $W = -1/2(n - \delta)^{2}$ 
where $\delta$ is the quantum defect for state $(n, l, j, m_{j})$. The Stark 
matrix element will be equal to zero unless it fulfills the requirement that 
$m_{j} = m_{j}'$ and $l = l' \pm 1$.

### Building the Stark Matrix

There are still a few pieces left before you will be able to build the Stark 
matrix. To properly calculate the Stark map for a given set of states, you 
need to include a large number of states of both higher and lower energies. 
The suggestion from @Zimmerman1979 is to include the full manifolds for at 
least $n \pm 4$. To build the list of states you plan on including in the 
Stark matrix, the function `state_list()` can be used. `state_list()` creates 
a matrix with columns n, l, and j and these columns contain all of the possible 
n, l, j combinations for a given $m_{j}$. For example, if looking at the 
states for the $n = 3$, $m_{j} = \frac{1}{2}$ manifold you would get:
```{r}
starkr::state_list(3, 3, 1/2, 0, 0)
```

There are some additional paramters in `state_list()` that allow for the 
addition of lower angular momentum states. For example, if `n_add_min` is set 
to 2, then all of the low angular momentum states ($l < 6$) would be included 
for nmin - 1 and nmin - 2. `n_add_max` is treated similarly, but on the higher 
n side. These additional states allow for the states that have the highest 
impact on the Stark map without adding too much computational load by inclding 
the full manifolds at those n's. 

Note: Because the different $m_{j}$ states do not interact, you will need to 
compute the state list and Stark matrix separately for each $m_{j}$.



## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
